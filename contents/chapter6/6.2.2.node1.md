# Node 1

In this node, we want to make a grid with *grid_x* by *grid_y* positions, and have them at *spacing* distance apart. 

![Result](./imgs/6.2.2-node1-endresult.png)

To do so, we created the following procedure:

![Procedure](./imgs/6.2.2-node1-procedure.png)

Let us break down what is happening in each line. 

## pattern.Grid

Before creating positions, a list of coordinates are needed to specify where to create those positions. This function generates the coordinates in a grid pattern based on the input, which may then later be used to create positions.

When creating a grid of positions, there will always be one more position in each direction than the number of spacesâ€”since spaces are between two points. 

**IMAGE**

number of spaces between positions in x-direction = `grid_x-1`
number of spaces between positions in y-direction = `grid_y-1`

To determine the dimension of the grid, 

x dimension = `(grid_x-1)*spacing`
y dimension = `(grid_y-1)*spacing`

## make.Positions and make.Point

From the coordinates returned by pattern.Grid, we are able to create positions in the model. 

Next, from the positions, we are able to create points. Points, polylines, polygons and other geometry are defined by positions and are dependent on them. Therefore, whenever you wish to create geometry, you need to first create positions. 

Here, points are created to help visualise where the positions are in the 3D viewer and to check if the outcome is as intended. This step is not strictly necessary. 

## modify.Move

We now want to move the grid of positions such that the corner of the grid starts at the world origin [0,0,0]. 

Since the grid has dimensions `(grid_x-1)*spacing` by `(grid_y-1)*spacing` with centre at the world origin, to shift it to the desired location, we will move it by half of its lengths:

`(grid_x-1)*spacing/2` in the x-direction; and
`(grid_y-1)*spacing/2` in the y-direction. 

The reason for the need to move the grid will be explained in the Node 2. 

#Node 1b

In this node, we want to make a closed rectangular polyline around each position created in the previous node. 

![Result](./imgs/6.2.3-node2-endresult.png)

To do so, we created the following procedure:

![Procedure](./imgs/6.2.3-node2-procedure.png)

## Defining of rectangle size as 'spacing'

If we want the rectangles created to be touching each other, each side of the rectangle will have length *spacing* by *spacing* (i.e. a square, since the grid was created with equal spacing). 

Using a value less than *spacing* creates a grid of rectangles with gaps in between; using a value more than *spacing* will create a grid of overlapping rectangles. 

![Varied lengths](./imgs/6.2.3-node2-spacing.png)

## query.Get

By now, you would have noticed that all the geometry that was created in the previous node is automatically transferred to this one. In order to make use of the positions created in the previous node, we use the query function. This function is very powerful, as you can filter what is gotten by specifying attribute conditions. 

Here, the query.Get function returns a list of the positions created previously, without returning the points we created. 

## For-each loop

A for-each loop is a quick way of performing repeated actions without having to do them one by one. Since we are creating a rectangle for each position, putting the steps to create a rectangle from a position in this loop allows us to repeat all the steps in the loop for every single position. 

"For-each *i* in *grid_ps*" simply means for each item in the list of items. Since *grid_ps* is defined as all the positions previously created, this translates as "for each position in the list of positions previously created".

## pattern.Rectangle

This function works similarly to pattern.Grid in the previous node. Instead of returning a list of coordinates arranged in a grid, it returns a list of 4 coordinates in a rectangule. 

The centre of the rectangle is given by `i@xyz`. This translates to "'xyz' attribute of *i*", which defines the xyz-coordinates of *i*. (See Chapter 2.4 for further explanation)

## Setting the mid-point xyz as attribute on rectangle

We want to set the xyz-coordinates of the midpoint of the rectangle as an attribute on the rectangle, so that the coordinates can be easily used later on. 

`rect@midpt_xyz` creates the attribute called *midpt_xyz* for *rect*, and sets its value to be `i@xyz` (the xyz-coordinates of the position created in the previous node).